package de.tuebingen.sfs.morphgen;

import de.tuebingen.sfs.utils.StringUtils;

import java.util.Map;

public class ReplaceRule extends Rule {

    private String[] inPattern;
    private String[] outPattern;

    public ReplaceRule(String lhs, String[] rhs, Map<String, String[]> groups, String name) {
        super(name);

        if (lhs.length() > 1 && lhs.charAt(0) == '[')
            inPattern = resolveGroup(lhs, groups);
        else
            inPattern = new String[]{lhs};

        if (rhs.length > 1)
            outPattern = rhs;
        else if (rhs.length == 0) {
            System.err.println(name + ": Empty right hand side!");
            inPattern = new String[0];
            outPattern = new String[0];
        } else if (rhs[0].length() > 1 && rhs[0].charAt(0) == '[')
            outPattern = resolveGroup(rhs[0], groups);
        else
            outPattern = new String[]{rhs[0]};
    }

    private String[] resolveGroup(String group, Map<String, String[]> groups) {
        String[] pattern;

        if (group.charAt(1) == '#') {
            String groupName = group.substring(1, group.length()-1);
            if (!groups.containsKey(groupName)) {
                System.err.println(name + ": Unknown group label '" + groupName + "'.");
                pattern = new String[0];
            }
            else
                pattern = groups.get(groupName);
        } else if (group.charAt(1) == '!') {
            pattern = StringUtils.split(group.substring(2, group.length()-1), ' ');
        } else {
            System.err.println(name + ": Invalid group pattern '" + group + "'.");
            pattern = new String[0];
        }

        return pattern;
    }

    /**
     * Apply rule to a string input.
     * @param s Input string
     * @return Outputs generated by the rule, null if rule not applicable
     */
    @Override
    public MorphRuleResult apply(String orig, String s) {
        System.err.println(name + " " + s);
        String[] results;
        if (inPattern.length > 0 && inPattern.length == outPattern.length) {
            String res = s;
            for (int i = 0; i < inPattern.length; i++)
                res = res.replaceAll(inPattern[i], outPattern[i]);
            results = new String[]{res};
        } else if (inPattern.length == 1) {
            results = new String[outPattern.length];
            for (int i = 0; i < outPattern.length; i++) {
                results[i] = s.replaceAll(inPattern[0], outPattern[i]);
            }
        } else if (outPattern.length == 1) {
            String res = s;
            for (int i = 0; i < inPattern.length; i++) {
                res = res.replaceAll(inPattern[i], outPattern[0]);
            }
            results = new String[]{res};
        } else
            return null;

        return new MorphRuleResult(orig, s, results);
    }
}
